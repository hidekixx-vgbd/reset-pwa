const { onRequest } = require("firebase-functions/v2/https");
const logger = require("firebase-functions/logger");
const OpenAI = require("openai");

// GitHub Pages のオリジン（必要ならあなたのドメインに絞る）
const ALLOWED_ORIGINS = new Set([
  "https://hidekixx-vgbd.github.io",
]);

const ZEN_TYPES = new Set(["dualism", "attachment", "impermanence"]);

// 2nd gen: cors オプションが使える（ただし細かい制御は自前が確実）
exports.classify = onRequest(
  {
    region: "asia-northeast1",
    secrets: ["OPENAI_API_KEY"],
  },
  async (req, res) => {
    // --- CORS ---
    const origin = req.headers.origin || "";
    if (ALLOWED_ORIGINS.has(origin)) {
      res.set("Access-Control-Allow-Origin", origin);
    }
    res.set("Vary", "Origin");
    res.set("Access-Control-Allow-Methods", "POST,OPTIONS");
    res.set("Access-Control-Allow-Headers", "Content-Type");

    if (req.method === "OPTIONS") return res.status(204).send("");
    if (req.method !== "POST") return res.status(405).json({ error: "Method Not Allowed" });

    // --- 入力 ---
    const { category, context, emotion } = req.body || {};
    if (!category || !emotion) {
      return res.status(400).json({ error: "category and emotion are required" });
    }

    // --- OpenAI ---
    try {
      const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

      // モデルは後で差し替え可能。最新のモデル指定は公式ガイドに従う。 :contentReference[oaicite:4]{index=4}
      const MODEL = process.env.OPENAI_MODEL || "gpt-5.2";

      const prompt = [
        "以下の入力を禅の3つの型のどれかに分類してください。",
        "",
        "選べる値は次の3つだけ：dualism, attachment, impermanence",
        "説明や理由は不要。出力は値1つだけ。",
        "",
        `カテゴリ: ${String(category)}`,
        `状況: ${String(context || "")}`,
        `感情: ${String(emotion)}`,
      ].join("\n");

      const r = await client.responses.create({
        model: MODEL,
        input: prompt,
        // 1語だけ返させる（暴れ防止）
        max_output_tokens: 16,
      });

      // OpenAI SDKの簡易テキスト取り出し（環境によりフィールド差が出る場合があるので保守的に）
      const text =
        (r.output_text && String(r.output_text).trim()) ||
        "";

      const zen_type = text.toLowerCase().match(/dualism|attachment|impermanence/)?.[0] || "attachment";

      // フェイルセーフ
      const finalType = ZEN_TYPES.has(zen_type) ? zen_type : "attachment";

      return res.status(200).json({ zen_type: finalType });
    } catch (e) {
      logger.error(e);
      // フォールバック（安全側）
      return res.status(200).json({ zen_type: "attachment" });
    }
  }
btnNext.addEventListener("click", async () => {
  if (!state.session.emotion || !state.session.category) return;

  show("ZEN");
  zenText.textContent = "…";

  // ローカル分類
  const zenType = classifyZenTypeLocal({
    category: state.session.category,
    context: state.session.contextText,
    emotion: state.session.emotion
  });

  state.session.zenType = zenType;
  zenText.textContent = ZEN_COPY[zenType];

  await sleep(900);

  state.session.action = pickRandom(ACTIONS);
  if (navigator.vibrate) navigator.vibrate(20);

  zenText2.textContent = ZEN_COPY[state.session.zenType];
  actionText.textContent = state.session.action;
  show("ACTION");
});

function classifyZenTypeLocal({ category, context, emotion }) {
  const t = `${context || ""}`.toLowerCase();
  const has = (...words) => words.some(w => t.includes(w));

  const dualismScore =
    (emotion === "怒り" ? 1 : 0) +
    (emotion === "苛立ち" ? 1 : 0) +
    (category === "work" ? 1 : 0) +
    (category === "relation" ? 1 : 0) +
    (has("評価", "否定", "ミス", "正しい", "間違い", "比較", "負け", "勝ち", "バカ", "見下") ? 2 : 0);

  const attachmentScore =
    (emotion === "不安" ? 1 : 0) +
    (emotion === "焦り" ? 1 : 0) +
    (category === "control" ? 2 : 0) +
    (has("思い通り", "コントロール", "期待", "ちゃんと", "すべき", "予定", "確認", "返信", "管理", "絶対") ? 2 : 0);

  const impermanenceScore =
    (emotion === "不安" ? 1 : 0) +
    (emotion === "落胆" ? 1 : 0) +
    (has("先が見えない", "どうなる", "不確実", "変化", "急", "予定変更", "終わり", "このまま") ? 2 : 0);

  const max = Math.max(dualismScore, attachmentScore, impermanenceScore);
  if (max === dualismScore && dualismScore > attachmentScore && dualismScore > impermanenceScore) return "dualism";
  if (max === impermanenceScore && impermanenceScore > dualismScore && impermanenceScore > attachmentScore) return "impermanence";
  return "attachment";
}

);
